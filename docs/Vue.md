# Вступ

<img align="right" height="120" src="images/Vue.png">

**Vue** — прогресивний фреймворк для створення інтерфейсів для користувачів. На відміну від інших фреймворків, **Vue** повністю розроблений для поступового впровадження. Основна бібліотека орієнтована лише на відображення; її легко зрозуміти та використовувати з іншими бібліотеками або в існуючих проєктах. Але **Vue** також здатний легко живити складні *SPA* (**S**ingle-**P**age **A**pplications — односторінкові веб-застосунки), коли використовується у поєднанні з сучасними підтримуючими бібліотеками.
<br><br>

> ...I thought "Ok, this is a view library", but just calling it English "View" sounds a bit too literal, so I threw "view" into Google Translate and found the French translation of it. It's just three letters, it looked cool, it's not taken on npm. So I was like "Ok, this is it!". So that'show I picked the name."
>
> — Evan You, творець **Vue**

# Упровадження

Як зазначено у вступі, **Vue** розроблений для поступового впровадження у проєкт. Це означає можливість його використання у кілька способів у залежності від вимог:
<br><br>

* Імпортування на сторінку як *CDN-пакет* (**C**ontent **D**elivey **N**etwork — мережа розповсюдження даних).
Це зручно для створення прототипів або навчання. Потрібно просто додати один рядок у тег `head`:
    ```html
    <script src="https://unpkg.com/vue@next"></script>
    ```
    Це забезпечить використання останньої версії **Vue**.
<br><br>

* Установлення через **npm**. Рекомендований спосіб для створення великих проєктів. Він повністю узгоджений із зв'язниками модулів, такими як [Webpack](https://webpack.js.org/) та [Rollup](https://rollupjs.org/guide/en/). Для встановлення останньої версії **Vue**, потрібно виконати команду:
    ```powershell
    npm install vue@next
    ```
<br>

* Використання **Vue CLI** (**C**ommand-**L**ine **I**nterface — інтерфейс через командний рядок). Є розширенням попереднього пункту, яке дозволяє швидко створювати *SPA*. Він має налаштування зібрання проєкту для сучасного робочого процесу. Можна швидко бачити результат разом з *hot reload* (миттєве відображення змін без перезавантаження сторінки), *lint on save* (виявлення вад коду з його збереженням) та готовими збірками проєкту. Для встановлення останньої версії **Vue CLI**, з правами адміністратора потрібно виконати команду:
    ```powershell
    npm install -g @vue/cli

    # '-g' вказує встановити Vue CLI глобально
    ```
    У проєкті [**"What is this?"**](https://github.com/mixolydian-b6/what-is-this) використовується саме цей спосіб.
<br><br>

* Завантаження JavaScript-файлів та власний їх хостинг. Так можна уникнути зібрання проєкту та імпортування **Vue** як *CDN-пакет*.
<br><br>

# Створення проєкту та його структура

Для створення застосунку **Vue** потрібно виконати команду:
```powershell
npm create what-is-this

# 'what-is-this' - назва застосунку
```
Вона запитує налаштування та надає 3 варіанти відповіді:
```powershell
? Please pick a preset:
  Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)
> Manually select features
```
Обираємо третій варіант — обрання налаштувань власноруч. Запропонований список має багато пунктів, про які можна не думати на початку. Залишаємо вказання версії **Vue** та `Linter / Formatter`:
```powershell
? Check the features needed for your project:
 (*) Choose Vue version
 ( ) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 ( ) Router
 ( ) Vuex
 ( ) CSS Pre-processors
>(*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing
```
Обираємо останню версію **Vue**:
```powershell
? Choose a version of Vue.js that you want to start the project with
  2.x
> 3.x (Preview)
```
Решта налаштувань — на ваш смак. Тепер ми маємо папку зі вказаною назвою, в якій знаходиться застосунок Hello World. Він має структуру будь-якого іншого, створеного з **Vue**. Розглянемо, як код перетворюється на веб-сторінку.

Весь код знаходиться у папці `src`, зміст якої:
* папка `assets` зберігає допоміжні файли (наприклад, зображення)
* папка `components` зберігає [*компоненти*](#Компоненти), з яких складається застосунок (у цьому прикладі — `HelloWorld.vue`)
* файл `App.vue` — головний файл застосунку, який є компонентом за структурою
* файл `main.js` додає компонент `App` у відповідне місце в документі-шаблоні `index.html`, який знаходиться у папці `public` поруч із папкою `assets` (це його єдина функція)

# Компоненти

## Будова
<br>

Ідея **Vue** — представлення застосунку як пов'язані компоненти, кожний з яких має свій HTML-, СSS- та JavaScript-код. Розглянемо структуру компонента:
```vue
<template>
<!-- HTML-код -->
</template>

<script>
// JavaScript-код

export default {
    name: 'Назва'
}
</script>

<style scoped>
/* CSS-код (необов'язкове 'scoped' вказує на застосування виключно у цьому компоненті) */
</style>
```
Як зазначенно у попередньому розділі, головний файл застосунку, `App.vue`, також є компонентом. Розглянемо кожну його частину в цьому прикладі:
<br><br>

* HTML
    ```vue
    <template>
        <img alt="Vue logo" src="./assets/logo.png">
        <HelloWorld msg="Welcome to Your Vue.js App"/>
    </template>
    ```
    Можна помітити незвичний тег — `HelloWorld`. Справді, це не тег. У цьому перша відмінність HTML-коду компонентів **Vue**-додатків: окрім тегів, він має інші компоненти. Синаксис їх використання збігається з використанням порожніх тегів. Порожніх, оскільки внутрішня структура компонентів уточнюється в їх файлах.
<br><br>

* CSS
    ```vue
    <style>
    #app {
        font-family: Avenir, Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-align: center;
        color: #2c3e50;
        margin-top: 60px;
    }
    </style>
    ```
    Визначення стилів не має відмінностей. Але, як на початку цього розділу, відкриваючий тег може мати додаткове слово `scoped`, яке вказує на застосування стилів лише для компонента, в якому вони визначені. Зазвичай, компонент `App` визначає глобальні стилі.
<br><br>

* JavaScript
    ```vue
    <script>
    import HelloWorld from './components/HelloWorld.vue';

    export default {
        name: 'App',
        components: {
            HelloWorld,
        },
    };
    </script>
    ```
    Кожний компонент повертає себе як об'єкт після слів `export default`. Він повинен мати свою назву для можливості бути використаним у інших компонентах. Але лише назви недостатньо для опису в більшості випадків. Компонент може використовувати інші компоненти, змінні, методи, приймати дані через атрибути, вимагати дій на певних етапах свого життєвого циклу... Інформація про ці особливості описується тут. У даному випадку, компонент `App` використовує інший — `HelloWorld`. Використовувані компонени перелічуються у значенні ключа `components`. Звичайно, зазначувані компоненти необхідно попередньо імпортувати з відповідних файлів.
<br><br>

## Ініціалізація з параметрами
<br>

Зазирнемо в опис компонента `HelloWorld`:
```javascript
export default {
    name: 'HelloWorld',
    props: {
        msg: String,
    },
};
```
Він не використовує інших компонентів, тому на ключ `components` можна не зважати. Однак, з'явився новий — `props` (від properties). Як зазначено вище, компоненти можуть приймати дані через атрибути. Згадаємо, як компонент `HelloWorld` додається в компонент `App`:
```html
<HelloWorld msg="Welcome to Your Vue.js App"/>
```
Саме такий випадок. Він приймає дані через атрибут `msg`. Для опису такої властивості компонента, ціатрибути перелічуються у значенні ключа `props`. Це можна зробити у 3 способи:
* переліком:
    ```javascript
    props: ['title', 'sum', 'sequence']
    ```
* зі вказанням типу прийманих даних:
    ```javascript
    props: {
        title: String,
        sum: Number,
        sequence: Array
    }
    ```
* зі вказанням типу прийманих даних та значення за замовчуванням:
    ```javascript
    props: {
        title: {
            type: String,
            default: 'Перші 10 членів послідовності Фібоначчі:'
        },
        sum: {
            type: Number,
            default: 88
        },
        sequence: {
            type: Array,
            default: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
        },
    }
    ```
Додання компонентів можна порівняти з інстанціюванням класів ООП: перелічені в значенні ключа `props` атрибути схожі на параметри в конструкторі, які також мають тип і можуть мати значення за замовчуванням.

Коли дані прийнято, додати їх у теги можна за допомогою подвійних фігурних дужок. У документації **Vue** їхназвали "mustaches", тому я називатиму їх вусиками. Їх синтаксис:
```vue
<header>{{ title }}</header>

<!-- тег header міститиме текстове подання значення title -->
```
Код у вусиках сприймається як JavaScript, тому над `title` можна виконувати операції:
```vue
<header>{{ title.replace('Angular', 'Vue') }}</header>
```
Розробники **Vue**, однак, радять бути обережним з цією можливістю: динамічний вміст тегів має сприйматися швидко під час читання коду. Також, це знижує ефективність у випадку використання оброблених значень укількох місцях. Тому варто уникати такого:
```vue
<p>{{ sequence.map(element => Math.pow(element, 2)) }}</p>

<!-- це сприймається не миттєво -->
```
У цьому інша відмінність HTML-коду компонентів **Vue**-додатків: динамічний вміст тегів за допомогою вусиків. Це робить елементи *реактивними* — змінна значеннь використовуваних у вусиках змінних миттєвозмінює їх стан на сторінці. Початковий стан можна зробити постійним, додавши беззначний атрибут `v-once`:
```vue
<header v-once>{{ title }}</header>
```
Однак, колись давно, нажаль, атрибути посварилися з вусиками, тому їх синтаксис не може бути використаний у значенні атрибута:
```vue
<a href="{{ link }}">посилання</a>

<!-- некоректний код -->
```
Як можна досягнути бажаного в цьому випадку, описано в наступному розділі.
<br><br>

# Дані

Як видно у попередньому розділі, логіка застосунку є децентралізованою. Тому компоненти мають локальні дані. Для їх визначення, в об'єкт опису компонента додається безпараметрова функція `data`, яка повертає об'єкт з ними. Розглянемо приклад з проєкту [**"What is this?"**](https://github.com/mixolydian-b6/what-is-this):
```javascript
export default {
    name: 'App',
    components: {ArticleLink},
    data() {
        return {
            buttonDisplay: 'none',
            logoAnimation: 'none',
            articles: []
        }
    }
    // ...
}
```
Компонент `App` використовує компонент `ArticleLink` та має локальні змінні `buttonDisplay`, `logoAnimation`, `articles` з деякими початковими значеннями. Як і з прийманими під час ініціалізації даними, елементи, які використовують локальні змінні, є *реактивними*.
<br><br>

## Використання
<br>

Як компоненти можуть використовувати локальні дані у значеннях атрибутів, якщо вусики не здатні це забезпечити? Для цього існує один з атрибутних префіксів **Vue** — `v-bind`:
```vue
<img v-bind:height="imgHeight" src="src/assets/logo.png">
```
Зображення має висоту, визначену миттєвим значенням локальної змінної `imgHeight`. Використання цього префікса змінює сприймання **Vue** значення атрибута: як і у вусиках, тепер це JavaScript-код, який має повертати значення, яке **Vue** спробує використати як кінцеве значення цього атрибута:
```vue
<img v-bind:height="imgHeight" alt="imgCaption.replace('Angular', 'Vue')" src="src/assets/logo.png">
```
Оскільки цей префікс є одним з використовуваних найчастіше, він має еквівалентне скорочення:
```vue
<img :height="imgHeight" src="src/assets/logo.png">

<!-- атрибути :height та v-bind:height — однакові -->
```
Так елемент компонента може використовувати локальні змінні.
<br><br>

## Визначення
<br>

Звичайно, можна зробити й навпаки: дозволити миттєвому значенню вмісту елемента визначати значення локальної змінної. Прив'язати змінну до значення вмісту  елемента можна за допомогою атрибута `v-model`:
```vue
<input type="text" v-model="inputValue">
```
Миттєвий вміст цього поля зберігається у локальній змінній `inputValue`. Цей атрибут має кілька розширень:
```vue
<!-- оновлення після події зміни замість події вводу -->

<input type="text" v-model.lazy="inputValue">  


<!-- конвертація у число за можливості -->

<input type="text" v-model.number="inputValue">  


<!-- видалення пробілів на початку та в кінці -->

<input type="text" v-model.trim="inputValue">
```
<br>

## Взаємодія
<br>

Змінити значення локальної змінної та отримати його можна у JavaScript-коді компонента:
```javascript
this.imgHeight = 250;  // оскільки зображення реактивне, його висота змінюється миттєво

let username = this.inputValue;  // отримання вмісту елемента зі значенням "inputValue" атрибута v-model
```
<br>

# Події

Прив'язати до події метод можна за допомогою атрибута `v-on` та її назви:
```vue
<button v-on:click="increment">{{ value }}</button>
```
Його значенням є назва виконуваного метода. Використовувані в компонентах методи визначаються в об'єктах їх опису:
```javascript
export default {
    name: 'App',
    methods: {
        increment() {
            this.value++;
        }
    }
}
```
Натиснення на цю кнопку інкрементує значення на ній. До речі, як і префікс `v-bind`, атрибут `v-on` має еквівалентне скорочення:
```vue
<button @click="increment">{{ value }}</button>

<!-- атрибути v-on:click та @click — однакові -->
```
<br>

Розглянемо приклад використання локальних змінних та реагування на події у проєкті [**"What is this?"**](https://github.com/mixolydian-b6/what-is-this):
```vue
<input type="text" v-model.trim="entity" @keyup="updateButton" placeholder="будь-що у Всесвіті">
<button :style="{display: buttonDisplay}" @click="findArticles">знайти статті</button>
```
Сторінка застосунку має поле вводу та кнопку пошуку статей у Вікіпедії за його вмістом. Він зв'язаний зі змінною `entity`, а подія його зміни — з методом `updateButton`. Значення CSS-властивості `display` кнопки визначається значенням змінної `buttonDisplay`; подія натиснення на кнопку викликає метод `findArticles`. Розглянемо ці методи:
```javascript
export default {
    name: 'App',
    components: {ArticleLink},
    data() {
        return {
            buttonDisplay: 'none',
            // ...
        }
    },
    methods: {
        updateButton() {
            this.buttonDisplay = this.entity ? 'inline-block' : 'none';
        },
        findArticles() {
            // ...
        }
    }
}
```
Спочатку, кнопка не відображається, оскільки `buttonDisplay = 'none'`. Кожна зміна вмісту поля перевіряє, чи є він порожнім. Якщо це так, значення `buttonDisplay` не змінюється та кнопка залишається не відображуваною. Інакше, `buttonDisplay = 'inline-block'`, що дозволяє їй показати себе. Мотивацією створення цієї логіки є відсутність сенсу в пошуку за нічим.
<br><br>

---

За [офіційною документацією **Vue**](https://v3.vuejs.org/guide/introduction.html).

**Віктор Бугайов** &nbsp;|&nbsp; студент НТУУ "КПІ", ФІОТ &nbsp;|&nbsp; vict.aiov@gmail.com

квітень 2021
